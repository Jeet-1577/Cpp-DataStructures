Introduction to Data Types
Data types in C++ define the nature of data being stored and manipulated. They specify:

How data is represented in memory
What operations can be performed on the data
The range of values data can hold
How much memory is allocated
Categories of Data Types in C++
1. Fundamental Data Types
Integer Types
int: Standard integer type, typically 4 bytes
short: Smaller integer, typically 2 bytes
long: Larger integer, at least 4 bytes (platform-dependent)
long long: Very large integer, at least 8 bytes
Integer types store whole numbers without fractional parts. Their size determines the range of values they can store.

Floating-Point Types
float: Single-precision floating-point, typically 4 bytes with ~7 digits precision
double: Double-precision floating-point, typically 8 bytes with ~15 digits precision
long double: Extended-precision floating-point, typically 12-16 bytes
Floating-point types represent real numbers with fractional parts, offering different levels of precision and range.

Character Types
char: Basic character type, 1 byte, stores a single character
wchar_t: Wide character type for international character sets
char16_t: UTF-16 character representation (introduced in C++11)
char32_t: UTF-32 character representation (introduced in C++11)
Character types store individual characters, with various encodings for international support.

Boolean Type
bool: Represents logical values (true or false)
Void Type
void: Represents absence of type, primarily used for functions that don't return values
2. Type Modifiers
Sign Modifiers
signed: Can represent both negative and positive numbers (default for most integer types)
unsigned: Can only represent non-negative numbers, but with larger positive range
Size Modifiers
short: Reduces size of an integer type
long: Increases size of an integer type
Type modifiers adjust the behavior and range of fundamental types.

3. Derived Data Types
Arrays
Collections of elements of the same type stored in contiguous memory locations. They have a fixed size determined at compile time.

Pointers
Variables that store memory addresses of other variables. They enable indirect access to values and dynamic memory management.

References
Aliases to existing variables. Unlike pointers, they must be initialized at declaration and cannot be reassigned.

Functions
Code blocks that perform specific tasks, can accept parameters and return values.

4. User-Defined Data Types
Structures
Collections of related variables of different data types grouped under a single name. Members are public by default.

Classes
Similar to structures but with default private access and support for methods, inheritance, and other object-oriented features.

Unions
Special data types where all members share the same memory location. Useful for memory conservation when variables are not needed simultaneously.

Enumerations
User-defined types consisting of named integer constants.

enum: Traditional enumeration type
enum class/enum struct: Scoped and strongly-typed enumerations (C++11)
Type Aliases
Allow creating alternative names for existing types:

typedef: Traditional way to create type aliases
using: Modern way to create type aliases (introduced in C++11)
Memory Management Considerations
Every data type has specific memory requirements
Type size affects program efficiency and memory usage
Type selection should consider range, precision, and memory constraints
Most types have platform-dependent implementations
Type Safety in C++
C++ is a strongly-typed language that enforces type checking
Implicit and explicit type conversions (casting) allow interoperability between types
Type safety helps prevent bugs and unexpected behavior